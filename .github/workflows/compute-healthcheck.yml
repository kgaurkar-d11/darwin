name: Darwin Compute - Health Check

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'darwin-compute/**'
      - 'darwin-cluster-manager/**'
      - 'init.sh'
      - 'setup.sh'
      - 'start.sh'
      - 'services.yaml'
      - '.github/workflows/compute-healthcheck.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  health-check:
    runs-on: [self-hosted, Linux, X64, darwin]
    defaults:
      run:
        working-directory: .
    env:
      KUBECONFIG: ./.setup/kindkubeconfig.yaml
      CONFIG_ENV: ./.setup/config.env

    steps:
      - name: Runner identity
        run: |
          echo "Runner: $RUNNER_NAME | OS: $RUNNER_OS | Arch: $RUNNER_ARCH"
          hostname

      - name: Cleanup previous artifacts
        run: |
          echo "üßπ Cleaning up previous run artifacts..."
          if command -v kind >/dev/null 2>&1; then
            kind delete cluster --name kind 2>/dev/null || true
          fi
          WORKSPACE_DIR="${{ github.workspace }}"
          if [ -d "$WORKSPACE_DIR/kind" ]; then
            sudo chmod -R u+w "$WORKSPACE_DIR/kind" 2>/dev/null || true
            sudo rm -rf "$WORKSPACE_DIR/kind/shared-storage" 2>/dev/null || true
          fi
          
          # Completely clean workspace to fix sparse checkout issues from previous runs
          echo "üóëÔ∏è Removing entire workspace for fresh checkout..."
          cd /
          sudo rm -rf "$WORKSPACE_DIR" || true
          mkdir -p "$WORKSPACE_DIR"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker
        uses: docker/setup-buildx-action@v3

      - name: Install prerequisites
        run: |
          # Install kubectl
          KUBECTL_VERSION=$(curl -L -s https://dl.k8s.io/release/stable.txt)
          echo "Installing kubectl $KUBECTL_VERSION"
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          # Verify the download is actually a binary (not an error page)
          if ! file kubectl | grep -q "ELF\|executable"; then
            echo "‚ùå Downloaded file is not a binary, retrying with direct URL..."
            rm -f kubectl
            curl -LO "https://storage.googleapis.com/kubernetes-release/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          fi
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client

          # Install Helm
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm version

          # Install Kind
          curl -Lo /tmp/kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x /tmp/kind && sudo mv /tmp/kind /usr/local/bin/kind
          kind version

          # Install yq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Configure services (init.sh)
        run: |
          echo "üìã Running init.sh to configure services..."
          rm -f .setup/enabled-services.yaml

          # Answers (13 prompts):
          # 1: compute (y) - service under test
          # 2-8: workspace, feature_store, mlflow, serve, catalog, chronos, workflow (all n)
          # 9: confirm (y)
          # 10-12: darwin sdk runtime, ray:2.37.0, ray:2.53.0 (all n)
          # 13: hermes-cli (n)
          printf "y\nn\nn\nn\nn\nn\nn\nn\ny\nn\nn\nn\nn\n" | ./init.sh --dev-mode || {
            echo "‚ùå init.sh failed"
            [ -f .setup/enabled-services.yaml ] && cat .setup/enabled-services.yaml
            exit 1
          }

          echo "‚úÖ Configuration created:"
          cat .setup/enabled-services.yaml

      - name: Build and setup cluster (setup.sh)
        run: |
          echo "üî® Running setup.sh..."
          export ENV=local
          ./setup.sh -y

          if [ -f $CONFIG_ENV ]; then
            echo "‚úÖ config.env created:"
            cat $CONFIG_ENV
          else
            echo "‚ùå config.env not found"
            exit 1
          fi

      - name: Verify cluster is ready
        run: |
          echo "üîç Verifying cluster status..."
          
          if [ ! -f "$KUBECONFIG" ]; then
            echo "‚ùå KUBECONFIG not found at $KUBECONFIG, cluster may not be ready"
            exit 1
          fi
          
          # Wait for cluster to be ready
          max_attempts=10
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if kubectl get nodes >/dev/null 2>&1; then
              echo "‚úÖ Cluster is accessible"
              kubectl get nodes
              break
            fi
            echo "Attempt $((attempt+1))/$max_attempts: Waiting for cluster..."
            sleep 5
            attempt=$((attempt+1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "‚ùå Cluster is not accessible"
            exit 1
          fi

      - name: Deploy to Kubernetes (start.sh)
        run: |
          echo "üöÄ Running start.sh..."

          # Background status monitor
          (
            while true; do
              sleep 30
              echo "‚è≥ [$(date +%H:%M:%S)] Status:"
              helm list -n darwin 2>/dev/null | head -3 || true
              kubectl get pods -n darwin --no-headers 2>/dev/null | head -5 | awk '{print "  " $1 ": " $3}' || true
            done
          ) &
          MONITOR_PID=$!

          set +e
          ./start.sh 2>&1 | tee /tmp/start.sh.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e

          kill $MONITOR_PID 2>/dev/null || true

          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå start.sh failed with exit code $EXIT_CODE"
            echo "=== Diagnostics ==="
            helm list -n darwin || true
            kubectl get pods -n darwin || true
            kubectl get events -n darwin --sort-by='.lastTimestamp' | tail -20 || true
            for pod in $(kubectl get pods -n darwin -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}' 2>/dev/null); do
              echo "--- Pod: $pod ---"
              kubectl describe pod -n darwin "$pod" 2>/dev/null | tail -30 || true
              kubectl logs -n darwin "$pod" --tail=30 2>/dev/null || true
            done
            exit 1
          fi

          echo "‚úÖ Deployment completed"

      - name: Wait for pods to be ready
        run: |
          echo "‚è≥ Waiting for darwin-compute and darwin-cluster-manager pods..."

          # Wait for darwin-compute
          echo "Waiting for darwin-compute..."
          if ! kubectl wait --for=condition=ready pod -l app.kubernetes.io/component=compute -n darwin --timeout=300s 2>/dev/null; then
            COMPUTE_POD=$(kubectl get pods -n darwin --no-headers 2>/dev/null | grep -E "darwin-compute" | head -1 | awk '{print $1}')
            if [ -n "$COMPUTE_POD" ]; then
              kubectl wait --for=condition=ready pod/$COMPUTE_POD -n darwin --timeout=300s || {
                echo "‚ùå darwin-compute pod did not become ready"
                kubectl describe pod/$COMPUTE_POD -n darwin || true
                exit 1
              }
            else
              echo "‚ùå Could not find darwin-compute pod"
              kubectl get pods -n darwin || true
              exit 1
            fi
          fi
          echo "‚úÖ darwin-compute pod is ready"

          # Wait for darwin-cluster-manager
          echo "Waiting for darwin-cluster-manager..."
          if ! kubectl wait --for=condition=ready pod -l app.kubernetes.io/component=cluster-manager -n darwin --timeout=300s 2>/dev/null; then
            DCM_POD=$(kubectl get pods -n darwin --no-headers 2>/dev/null | grep -E "darwin-cluster-manager" | head -1 | awk '{print $1}')
            if [ -n "$DCM_POD" ]; then
              kubectl wait --for=condition=ready pod/$DCM_POD -n darwin --timeout=300s || {
                echo "‚ùå darwin-cluster-manager pod did not become ready"
                kubectl describe pod/$DCM_POD -n darwin || true
                exit 1
              }
            else
              echo "‚ùå Could not find darwin-cluster-manager pod"
              kubectl get pods -n darwin || true
              exit 1
            fi
          fi
          echo "‚úÖ darwin-cluster-manager pod is ready"

          kubectl get pods -n darwin | grep -E "compute|cluster-manager"

      - name: Test health endpoints
        run: |
          echo "üè• Testing health endpoints..."

          # Test darwin-compute /health endpoint
          echo ""
          echo "‚îÅ‚îÅ‚îÅ Testing darwin-compute (/compute/health) ‚îÅ‚îÅ‚îÅ"
          for i in $(seq 1 30); do
            if curl -f -s http://localhost/compute/health > /dev/null 2>&1; then
              echo "‚úÖ darwin-compute endpoint accessible"
              break
            fi
            [ $i -eq 30 ] && { echo "‚ùå darwin-compute endpoint not accessible"; exit 1; }
            sleep 2
          done

          compute_response=$(curl -s http://localhost/compute/health)
          echo "Response: $compute_response"

          python3 << EOF
          import json
          import sys
          try:
              data = json.loads('''$compute_response''')
              status = data.get('status', '')
              if 'SUCCESS' not in status:
                  print(f"‚ùå darwin-compute: status is '{status}', expected 'SUCCESS'")
                  sys.exit(1)
              print("‚úÖ darwin-compute health check passed!")
          except json.JSONDecodeError as e:
              print(f"‚ùå darwin-compute: Invalid JSON: {e}")
              sys.exit(1)
          EOF

          # Test darwin-cluster-manager /healthcheck endpoint
          echo ""
          echo "‚îÅ‚îÅ‚îÅ Testing darwin-cluster-manager (/cluster-manager/healthcheck) ‚îÅ‚îÅ‚îÅ"
          for i in $(seq 1 30); do
            if curl -f -s http://localhost/cluster-manager/healthcheck > /dev/null 2>&1; then
              echo "‚úÖ darwin-cluster-manager endpoint accessible"
              break
            fi
            [ $i -eq 30 ] && { echo "‚ùå darwin-cluster-manager endpoint not accessible"; exit 1; }
            sleep 2
          done

          dcm_response=$(curl -s http://localhost/cluster-manager/healthcheck)
          echo "Response: $dcm_response"
          
          python3 << EOF
          import json
          import sys
          try:
              data = json.loads('''$dcm_response''')
              status = data.get('status', '')
              if 'SUCCESS' not in status:
                  print(f"‚ùå darwin-cluster-manager: status is '{status}', expected 'SUCCESS'")
                  sys.exit(1)
              print("‚úÖ darwin-cluster-manager health check passed!")
          except json.JSONDecodeError as e:
              print(f"‚ùå darwin-cluster-manager: Invalid JSON: {e}")
              sys.exit(1)
          EOF

          echo ""
          echo "‚úÖ All health checks passed!"

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up..."
          echo "Current disk usage:"
          df -h
          echo ""
          echo "Cleaning up kind cluster and port-forwards..."
          pkill -f "kubectl port-forward" || true
          kind delete cluster --name kind 2>/dev/null || true
          echo ""
          echo "Cleaning up Docker resources..."
          docker image prune -af --filter "label=maintainer=darwin" || true
          docker system prune -f || true
          docker volume prune -f || true
          echo ""
          echo "Cleaning up apt cache..."
          sudo apt-get clean || true
          sudo rm -rf /var/lib/apt/lists/* || true
          echo ""
          echo "Disk usage after cleanup:"
          df -h
